<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Collision Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        h1 {
            margin-bottom: 10px;
            color: #fff;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        label {
            font-size: 14px;
        }
        input[type="range"] {
            width: 120px;
        }
        .value-display {
            min-width: 45px;
            text-align: right;
            font-family: monospace;
        }
        .canvas-container {
            position: relative;
            width: 800px;
            height: 600px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            border: 2px solid #444;
            border-radius: 8px;
        }
        #glCanvas {
            background: #0f0f1a;
        }
        #overlayCanvas {
            background: transparent;
            cursor: crosshair;
        }
        .info {
            margin-top: 15px;
            font-size: 13px;
            color: #888;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Plinko Collision Simulator</h1>
    <div class="controls">
        <div class="control-group">
            <label>Damping:</label>
            <input type="range" id="damping" min="0" max="1" step="0.01" value="0.5">
            <span class="value-display" id="dampingValue">0.50</span>
        </div>
        <div class="control-group">
            <label>Peg Radius:</label>
            <input type="range" id="pegRadius" min="10" max="60" step="1" value="26">
            <span class="value-display" id="pegRadiusValue">26</span>
        </div>
    </div>
    <div class="canvas-container">
        <canvas id="glCanvas" width="800" height="600"></canvas>
        <canvas id="overlayCanvas" width="800" height="600"></canvas>
    </div>
    <div class="info">
        Hover over the colored region to see the ball trajectory from that position.
    </div>
    <div id="status" style="margin-top: 10px; color: #888; font-size: 12px;"></div>

    <script>
        // ==================== WebGL Setup ====================
        const glCanvas = document.getElementById('glCanvas');
        const gl = glCanvas.getContext('webgl');
        
        const overlayCanvas = document.getElementById('overlayCanvas');
        const ctx = overlayCanvas.getContext('2d');

        if (!gl) {
            alert('WebGL not supported');
        }

        // Physics parameters
        let damping = 0.5;
        const gravity = 500.0;
        let pegRadius = 26.0;

        // Peg array configuration
        const pegRows = 3;
        const pegsPerRow = 7;
        const pegSpacingX = 100;
        const pegSpacingY = 120;
        const pegStartY = 200;

        function generatePegs() {
            const pegs = [];
            for (let row = 0; row < pegRows; row++) {
                const rowOffset = (row % 2) * (pegSpacingX / 2);
                const rowPegCount = pegsPerRow - (row % 2);
                const rowStartX = (glCanvas.width - (rowPegCount - 1) * pegSpacingX) / 2 + rowOffset - (row % 2) * (pegSpacingX / 2);
                for (let col = 0; col < rowPegCount; col++) {
                    pegs.push({ x: rowStartX + col * pegSpacingX, y: pegStartY + row * pegSpacingY });
                }
            }
            return pegs;
        }

        const pegs = generatePegs();
        const MAX_PEGS = 24;

        const bucketColors = [
            [1.0, 0.0, 0.0], [1.0, 0.5, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0],
            [0.0, 0.0, 1.0], [0.294, 0.0, 0.51], [0.545, 0.0, 1.0]
        ];
        const numBuckets = 7;
        const bucketHeight = 60;
        const bucketY = glCanvas.height - bucketHeight - 10;
        const bucketStartX = 20;
        const bucketWidth = (glCanvas.width - 40) / numBuckets;
        const topRegionHeight = pegStartY - pegRadius - 20;

        // ==================== Shaders ====================
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Simulation shader - renders one sample with random dithering
        const simFragmentShaderSource = `
            precision highp float;
            varying vec2 v_uv;
            
            uniform float u_damping;
            uniform float u_pegRadius;
            uniform float u_gravity;
            uniform float u_topRegionHeight;
            uniform float u_bucketY;
            uniform float u_bucketStartX;
            uniform float u_bucketWidth;
            uniform vec2 u_pegs[${MAX_PEGS}];
            uniform int u_numPegs;
            uniform vec3 u_bucketColors[7];
            uniform vec3 u_bgColor;
            uniform float u_seed; // Random seed for this frame
            uniform vec2 u_resolution;
            
            const int MAX_BOUNCES = 50;
            const float EPSILON = 0.00001;
            
            // Hash function for pseudo-random numbers
            float hash(vec2 p) {
                vec3 p3 = fract(vec3(p.xyx) * 0.1031);
                p3 += dot(p3, p3.yzx + 33.33);
                return fract((p3.x + p3.y) * p3.z);
            }
            
            vec2 hash2(vec2 p, float seed) {
                return vec2(
                    hash(p + vec2(seed, 0.0)),
                    hash(p + vec2(0.0, seed + 17.31))
                );
            }
            
            float solveQuadraticMin(float a, float b, float c) {
                if (abs(a) < 1e-10) {
                    if (abs(b) < 1e-10) return -1.0;
                    float t = -c / b;
                    return t > EPSILON ? t : -1.0;
                }
                float disc = b * b - 4.0 * a * c;
                if (disc < 0.0) return -1.0;
                float sqrtDisc = sqrt(disc);
                float t1 = (-b - sqrtDisc) / (2.0 * a);
                float t2 = (-b + sqrtDisc) / (2.0 * a);
                if (t1 > EPSILON) return t1;
                if (t2 > EPSILON) return t2;
                return -1.0;
            }
            
            vec2 getPosition(vec2 p0, vec2 v0, float t) {
                return p0 + v0 * t + vec2(0.0, 0.5 * u_gravity * t * t);
            }
            
            vec2 getVelocity(vec2 v0, float t) {
                return v0 + vec2(0.0, u_gravity * t);
            }
            
            float findCollisionTime(vec2 p0, vec2 v0, vec2 center) {
                float r2 = u_pegRadius * u_pegRadius;
                float tMax = 3.0;
                float step = tMax / 100.0; // Finer sampling
                float prevT = 0.0;
                float prevD = dot(p0 - center, p0 - center) - r2;
                
                for (int i = 1; i <= 100; i++) {
                    float t = float(i) * step;
                    vec2 pos = getPosition(p0, v0, t);
                    float d = dot(pos - center, pos - center) - r2;
                    
                    if (prevD > 0.0 && d < 0.0) {
                        float lo = prevT, hi = t;
                        for (int j = 0; j < 32; j++) { // More bisection iterations
                            float mid = (lo + hi) * 0.5;
                            vec2 midPos = getPosition(p0, v0, mid);
                            float midD = dot(midPos - center, midPos - center) - r2;
                            if (midD > 0.0) lo = mid; else hi = mid;
                        }
                        float collisionT = (lo + hi) * 0.5;
                        vec2 collisionPos = getPosition(p0, v0, collisionT);
                        vec2 collisionVel = getVelocity(v0, collisionT);
                        if (dot(collisionVel, center - collisionPos) > 0.0) return collisionT;
                    }
                    prevT = t;
                    prevD = d;
                }
                return -1.0;
            }
            
            vec2 computeBounceVelocity(vec2 pos, vec2 vel, vec2 center) {
                vec2 n = normalize(pos - center);
                float vDotN = dot(vel, n);
                if (vDotN >= 0.0) return vel;
                vec2 vn = vDotN * n;
                return vel - vn - u_damping * vn;
            }
            
            float findBucketHitTime(vec2 p0, vec2 v0) {
                return solveQuadraticMin(0.5 * u_gravity, v0.y, p0.y - u_bucketY);
            }
            
            int getBucketIndex(float x) {
                if (x < u_bucketStartX || x >= u_bucketStartX + u_bucketWidth * 7.0) return -1;
                return int((x - u_bucketStartX) / u_bucketWidth);
            }
            
            vec2 getPeg(int idx) {
                for (int i = 0; i < ${MAX_PEGS}; i++) {
                    if (i == idx) return u_pegs[i];
                }
                return vec2(-1000.0);
            }
            
            vec3 getBucketColor(int idx) {
                if (idx == 0) return u_bucketColors[0];
                if (idx == 1) return u_bucketColors[1];
                if (idx == 2) return u_bucketColors[2];
                if (idx == 3) return u_bucketColors[3];
                if (idx == 4) return u_bucketColors[4];
                if (idx == 5) return u_bucketColors[5];
                if (idx == 6) return u_bucketColors[6];
                return u_bgColor;
            }
            
            int simulateDrop(vec2 startPos) {
                vec2 p0 = startPos;
                vec2 v0 = vec2(0.0);
                
                for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
                    float earliestTime = 1000.0;
                    int collidedPeg = -1;
                    
                    for (int i = 0; i < ${MAX_PEGS}; i++) {
                        if (i >= u_numPegs) break;
                        float t = findCollisionTime(p0, v0, u_pegs[i]);
                        if (t > EPSILON && t < earliestTime) {
                            earliestTime = t;
                            collidedPeg = i;
                        }
                    }
                    
                    float bucketTime = findBucketHitTime(p0, v0);
                    
                    if (bucketTime > EPSILON && bucketTime < earliestTime) {
                        vec2 finalPos = getPosition(p0, v0, bucketTime);
                        return getBucketIndex(finalPos.x);
                    }
                    
                    if (collidedPeg >= 0 && earliestTime < 10.0) {
                        vec2 collisionPos = getPosition(p0, v0, earliestTime);
                        vec2 collisionVel = getVelocity(v0, earliestTime);
                        vec2 pegPos = getPeg(collidedPeg);
                        v0 = computeBounceVelocity(collisionPos, collisionVel, pegPos);
                        // Small offset along normal to prevent re-collision
                        p0 = collisionPos + normalize(collisionPos - pegPos) * 0.01;
                    } else {
                        return -1;
                    }
                }
                return -1;
            }
            
            void main() {
                vec2 pixelCoord = vec2(v_uv.x * u_resolution.x, (1.0 - v_uv.y) * u_resolution.y);
                
                if (pixelCoord.y > u_topRegionHeight) {
                    gl_FragColor = vec4(u_bgColor, 1.0);
                    return;
                }
                
                // Add random dither within pixel
                vec2 dither = hash2(pixelCoord, u_seed) - 0.5;
                vec2 jitteredCoord = pixelCoord + dither;
                
                int bucketIdx = simulateDrop(jitteredCoord);
                vec3 color = getBucketColor(bucketIdx);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Accumulation shader - blends new sample with accumulated result
        const accumFragmentShaderSource = `
            precision highp float;
            varying vec2 v_uv;
            uniform sampler2D u_newSample;
            uniform sampler2D u_accumulated;
            uniform float u_weight; // Weight for new sample (1/N)
            
            void main() {
                vec3 newColor = texture2D(u_newSample, v_uv).rgb;
                vec3 accColor = texture2D(u_accumulated, v_uv).rgb;
                vec3 blended = mix(accColor, newColor, u_weight);
                gl_FragColor = vec4(blended, 1.0);
            }
        `;

        // Display shader - just shows a texture
        const displayFragmentShaderSource = `
            precision highp float;
            varying vec2 v_uv;
            uniform sampler2D u_texture;
            
            void main() {
                gl_FragColor = texture2D(u_texture, v_uv);
            }
        `;

        // Compile shader helper
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Create shaders
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const simFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, simFragmentShaderSource);
        const accumFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, accumFragmentShaderSource);
        const displayFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, displayFragmentShaderSource);

        const simProgram = createProgram(gl, vertexShader, simFragmentShader);
        const accumProgram = createProgram(gl, vertexShader, accumFragmentShader);
        const displayProgram = createProgram(gl, vertexShader, displayFragmentShader);

        // Create fullscreen quad
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        // Get uniform locations for simulation shader
        const simUniforms = {
            position: gl.getAttribLocation(simProgram, 'a_position'),
            damping: gl.getUniformLocation(simProgram, 'u_damping'),
            pegRadius: gl.getUniformLocation(simProgram, 'u_pegRadius'),
            gravity: gl.getUniformLocation(simProgram, 'u_gravity'),
            topRegionHeight: gl.getUniformLocation(simProgram, 'u_topRegionHeight'),
            bucketY: gl.getUniformLocation(simProgram, 'u_bucketY'),
            bucketStartX: gl.getUniformLocation(simProgram, 'u_bucketStartX'),
            bucketWidth: gl.getUniformLocation(simProgram, 'u_bucketWidth'),
            numPegs: gl.getUniformLocation(simProgram, 'u_numPegs'),
            bgColor: gl.getUniformLocation(simProgram, 'u_bgColor'),
            seed: gl.getUniformLocation(simProgram, 'u_seed'),
            resolution: gl.getUniformLocation(simProgram, 'u_resolution'),
            pegs: [],
            bucketColors: []
        };
        for (let i = 0; i < MAX_PEGS; i++) simUniforms.pegs.push(gl.getUniformLocation(simProgram, `u_pegs[${i}]`));
        for (let i = 0; i < 7; i++) simUniforms.bucketColors.push(gl.getUniformLocation(simProgram, `u_bucketColors[${i}]`));

        // Get uniform locations for accumulation shader
        const accumUniforms = {
            position: gl.getAttribLocation(accumProgram, 'a_position'),
            newSample: gl.getUniformLocation(accumProgram, 'u_newSample'),
            accumulated: gl.getUniformLocation(accumProgram, 'u_accumulated'),
            weight: gl.getUniformLocation(accumProgram, 'u_weight')
        };

        // Get uniform locations for display shader
        const displayUniforms = {
            position: gl.getAttribLocation(displayProgram, 'a_position'),
            texture: gl.getUniformLocation(displayProgram, 'u_texture')
        };

        // Create framebuffers and textures for ping-pong
        function createFramebuffer(gl) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, glCanvas.width, glCanvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            return { framebuffer, texture };
        }

        const fbSample = createFramebuffer(gl);    // New sample
        const fbAccum1 = createFramebuffer(gl);    // Accumulated result (ping)
        const fbAccum2 = createFramebuffer(gl);    // Accumulated result (pong)

        // Progressive rendering state
        let sampleCount = 0;
        let animationId = null;
        let useAccum1 = true; // Toggle for ping-pong
        const maxSamples = 300; // Stop after this many samples

        // Render one sample
        function renderSample(seed) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbSample.framebuffer);
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.useProgram(simProgram);

            // Set uniforms
            gl.uniform1f(simUniforms.damping, damping);
            gl.uniform1f(simUniforms.pegRadius, pegRadius);
            gl.uniform1f(simUniforms.gravity, gravity);
            gl.uniform1f(simUniforms.topRegionHeight, topRegionHeight);
            gl.uniform1f(simUniforms.bucketY, bucketY);
            gl.uniform1f(simUniforms.bucketStartX, bucketStartX);
            gl.uniform1f(simUniforms.bucketWidth, bucketWidth);
            gl.uniform1i(simUniforms.numPegs, pegs.length);
            gl.uniform3f(simUniforms.bgColor, 15/255, 15/255, 26/255);
            gl.uniform1f(simUniforms.seed, seed);
            gl.uniform2f(simUniforms.resolution, glCanvas.width, glCanvas.height);

            for (let i = 0; i < MAX_PEGS; i++) {
                if (i < pegs.length) gl.uniform2f(simUniforms.pegs[i], pegs[i].x, pegs[i].y);
                else gl.uniform2f(simUniforms.pegs[i], -1000, -1000);
            }
            for (let i = 0; i < 7; i++) gl.uniform3fv(simUniforms.bucketColors[i], bucketColors[i]);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(simUniforms.position);
            gl.vertexAttribPointer(simUniforms.position, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        // Accumulate sample
        function accumulateSample(weight) {
            const srcAccum = useAccum1 ? fbAccum1 : fbAccum2;
            const dstAccum = useAccum1 ? fbAccum2 : fbAccum1;

            gl.bindFramebuffer(gl.FRAMEBUFFER, dstAccum.framebuffer);
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.useProgram(accumProgram);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, fbSample.texture);
            gl.uniform1i(accumUniforms.newSample, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, srcAccum.texture);
            gl.uniform1i(accumUniforms.accumulated, 1);

            gl.uniform1f(accumUniforms.weight, weight);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(accumUniforms.position);
            gl.vertexAttribPointer(accumUniforms.position, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            useAccum1 = !useAccum1;
        }

        // Display accumulated result
        function displayResult() {
            const srcAccum = useAccum1 ? fbAccum1 : fbAccum2;

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.useProgram(displayProgram);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, srcAccum.texture);
            gl.uniform1i(displayUniforms.texture, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(displayUniforms.position);
            gl.vertexAttribPointer(displayUniforms.position, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        // Progressive rendering loop
        function progressiveRender() {
            sampleCount++;
            const seed = Math.random() * 1000;

            renderSample(seed);

            if (sampleCount === 1) {
                // First sample: just copy to accumulator
                const dstAccum = useAccum1 ? fbAccum1 : fbAccum2;
                gl.bindFramebuffer(gl.FRAMEBUFFER, dstAccum.framebuffer);
                gl.viewport(0, 0, glCanvas.width, glCanvas.height);
                gl.useProgram(displayProgram);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, fbSample.texture);
                gl.uniform1i(displayUniforms.texture, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(displayUniforms.position);
                gl.vertexAttribPointer(displayUniforms.position, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            } else {
                // Blend: weight = 1/N for new sample
                const weight = 1.0 / sampleCount;
                accumulateSample(weight);
            }

            displayResult();
            
            document.getElementById('status').textContent = `Progressive AA: ${sampleCount}/${maxSamples} samples`;

            // Continue refining until max samples reached
            if (sampleCount < maxSamples) {
                animationId = requestAnimationFrame(progressiveRender);
            } else {
                animationId = null;
            }
        }

        // Reset progressive rendering
        function resetProgressive() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            sampleCount = 0;
            useAccum1 = true;
            progressiveRender();
        }

        // ==================== 2D Canvas Overlay ====================
        function getBucketRects() {
            const buckets = [];
            const hexColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#8b00ff'];
            for (let i = 0; i < numBuckets; i++) {
                buckets.push({
                    x: bucketStartX + i * bucketWidth,
                    y: bucketY,
                    width: bucketWidth,
                    height: bucketHeight,
                    color: hexColors[i]
                });
            }
            return buckets;
        }
        const buckets = getBucketRects();

        let hoverPos = null;

        function solveQuadratic(a, b, c) {
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) return [];
                return [-c/b];
            }
            const disc = b*b - 4*a*c;
            if (disc < 0) return [];
            const sqrtD = Math.sqrt(disc);
            return [(-b - sqrtD)/(2*a), (-b + sqrtD)/(2*a)].sort((a,b) => a-b);
        }

        function getPositionJS(p0, v0, t) {
            return { x: p0.x + v0.x * t, y: p0.y + v0.y * t + 0.5 * gravity * t * t };
        }

        function getVelocityJS(v0, t) {
            return { x: v0.x, y: v0.y + gravity * t };
        }

        function findCollisionTimeJS(p0, v0, center, radius) {
            const r2 = radius * radius;
            const tMax = 3, step = tMax / 100; // Finer sampling
            let prevT = 0, prevD = (p0.x - center.x)**2 + (p0.y - center.y)**2 - r2;
            
            for (let i = 1; i <= 100; i++) {
                const t = i * step;
                const pos = getPositionJS(p0, v0, t);
                const d = (pos.x - center.x)**2 + (pos.y - center.y)**2 - r2;
                
                if (prevD > 0 && d < 0) {
                    let lo = prevT, hi = t;
                    for (let j = 0; j < 32; j++) { // More bisection iterations
                        const mid = (lo + hi) / 2;
                        const midPos = getPositionJS(p0, v0, mid);
                        const midD = (midPos.x - center.x)**2 + (midPos.y - center.y)**2 - r2;
                        if (midD > 0) lo = mid; else hi = mid;
                    }
                    const collisionT = (lo + hi) / 2;
                    const collisionPos = getPositionJS(p0, v0, collisionT);
                    const collisionVel = getVelocityJS(v0, collisionT);
                    const toCenter = { x: center.x - collisionPos.x, y: center.y - collisionPos.y };
                    if (collisionVel.x * toCenter.x + collisionVel.y * toCenter.y > 0) return collisionT;
                }
                prevT = t;
                prevD = d;
            }
            return null;
        }

        function findEarliestCollisionJS(p0, v0) {
            let earliestTime = null, collidedPeg = null;
            for (const peg of pegs) {
                const t = findCollisionTimeJS(p0, v0, peg, pegRadius);
                if (t !== null && (earliestTime === null || t < earliestTime)) {
                    earliestTime = t;
                    collidedPeg = peg;
                }
            }
            return { time: earliestTime, peg: collidedPeg };
        }

        function computeBounceVelocityJS(pos, vel, center) {
            const dx = pos.x - center.x, dy = pos.y - center.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            const nx = dx/len, ny = dy/len;
            const vDotN = vel.x * nx + vel.y * ny;
            if (vDotN >= 0) return vel;
            const vnx = vDotN * nx, vny = vDotN * ny;
            return { x: vel.x - vnx - damping * vnx, y: vel.y - vny - damping * vny };
        }

        function computeTrajectory(startPos) {
            const segments = [];
            let p0 = { ...startPos }, v0 = { x: 0, y: 0 };
            
            for (let bounce = 0; bounce < 50; bounce++) {
                const collision = findEarliestCollisionJS(p0, v0);
                const bucketTime = solveQuadratic(0.5 * gravity, v0.y, p0.y - bucketY).find(t => t > 0.0001) || Infinity;
                const collisionTime = collision.time !== null ? collision.time : Infinity;
                
                if (bucketTime < collisionTime && bucketTime < 10) {
                    segments.push({ p0: {...p0}, v0: {...v0}, duration: bucketTime, endsWithBounce: false });
                    break;
                }
                if (collisionTime < 10) {
                    segments.push({ p0: {...p0}, v0: {...v0}, duration: collisionTime, endsWithBounce: true });
                    const collisionPos = getPositionJS(p0, v0, collisionTime);
                    const collisionVel = getVelocityJS(v0, collisionTime);
                    v0 = computeBounceVelocityJS(collisionPos, collisionVel, collision.peg);
                    const norm = Math.sqrt((collisionPos.x - collision.peg.x)**2 + (collisionPos.y - collision.peg.y)**2);
                    p0 = {
                        x: collisionPos.x + (collisionPos.x - collision.peg.x) / norm * 0.01,
                        y: collisionPos.y + (collisionPos.y - collision.peg.y) / norm * 0.01
                    };
                } else {
                    segments.push({ p0: {...p0}, v0: {...v0}, duration: 10, endsWithBounce: false });
                    break;
                }
            }
            return segments;
        }

        function drawOverlay() {
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            for (const peg of pegs) {
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 100, 200, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#6666cc';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#6666cc';
                ctx.fill();
            }
            
            for (const bucket of buckets) {
                ctx.fillStyle = bucket.color;
                ctx.fillRect(bucket.x, bucket.y, bucket.width, bucket.height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(bucket.x, bucket.y, bucket.width, bucket.height);
            }
            
            if (hoverPos && hoverPos.y < topRegionHeight) {
                const segments = computeTrajectory(hoverPos);
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                
                for (const segment of segments) {
                    ctx.beginPath();
                    for (let i = 0; i <= 100; i++) {
                        const t = (i / 100) * segment.duration;
                        const pos = getPositionJS(segment.p0, segment.v0, t);
                        if (i === 0) ctx.moveTo(pos.x, pos.y);
                        else ctx.lineTo(pos.x, pos.y);
                    }
                    ctx.stroke();
                    if (segment.endsWithBounce) {
                        const bouncePos = getPositionJS(segment.p0, segment.v0, segment.duration);
                        ctx.beginPath();
                        ctx.arc(bouncePos.x, bouncePos.y, 5, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff4444';
                        ctx.fill();
                    }
                }
                
                ctx.beginPath();
                ctx.arc(hoverPos.x, hoverPos.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // ==================== Event Handlers ====================
        const dampingSlider = document.getElementById('damping');
        const pegRadiusSlider = document.getElementById('pegRadius');
        const dampingValue = document.getElementById('dampingValue');
        const pegRadiusValue = document.getElementById('pegRadiusValue');

        dampingSlider.addEventListener('input', () => {
            damping = parseFloat(dampingSlider.value);
            dampingValue.textContent = damping.toFixed(2);
            resetProgressive();
            drawOverlay();
        });

        pegRadiusSlider.addEventListener('input', () => {
            pegRadius = parseFloat(pegRadiusSlider.value);
            pegRadiusValue.textContent = pegRadius.toFixed(0);
            resetProgressive();
            drawOverlay();
        });

        function getMousePos(e) {
            const rect = overlayCanvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        overlayCanvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            if (pos.y < topRegionHeight) {
                hoverPos = pos;
                drawOverlay();
            } else if (hoverPos !== null) {
                hoverPos = null;
                drawOverlay();
            }
        });

        overlayCanvas.addEventListener('mouseleave', () => {
            if (hoverPos !== null) {
                hoverPos = null;
                drawOverlay();
            }
        });

        // Initial render
        resetProgressive();
        drawOverlay();
    </script>
</body>
</html>
