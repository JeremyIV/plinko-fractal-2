<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Collision Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        h1 {
            margin-bottom: 10px;
            color: #fff;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        label {
            font-size: 14px;
        }
        input[type="range"] {
            width: 120px;
        }
        .value-display {
            min-width: 45px;
            text-align: right;
            font-family: monospace;
        }
        .canvas-container {
            position: relative;
            width: 800px;
            height: 600px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            border: 2px solid #444;
            border-radius: 8px;
        }
        #glCanvas {
            background: #0f0f1a;
        }
        #overlayCanvas {
            background: transparent;
            cursor: crosshair;
        }
        .info {
            margin-top: 15px;
            font-size: 13px;
            color: #888;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Plinko Collision Simulator</h1>
    <div class="controls">
        <div class="control-group">
            <label>Damping:</label>
            <input type="range" id="damping" min="0" max="1" step="0.01" value="0.5">
            <span class="value-display" id="dampingValue">0.50</span>
        </div>
        <div class="control-group">
            <label>Peg Radius:</label>
            <input type="range" id="pegRadius" min="10" max="60" step="1" value="26">
            <span class="value-display" id="pegRadiusValue">26</span>
        </div>
    </div>
    <div class="canvas-container">
        <canvas id="glCanvas" width="800" height="600"></canvas>
        <canvas id="overlayCanvas" width="800" height="600"></canvas>
    </div>
    <div class="info">
        Hover over the colored region to see the ball trajectory from that position.
    </div>
    <div id="status" style="margin-top: 10px; color: #888; font-size: 12px;"></div>

    <script>
        // ==================== WebGL Setup ====================
        const glCanvas = document.getElementById('glCanvas');
        const gl = glCanvas.getContext('webgl');
        
        const overlayCanvas = document.getElementById('overlayCanvas');
        const ctx = overlayCanvas.getContext('2d');

        if (!gl) {
            alert('WebGL not supported, falling back to CPU rendering');
        }

        // Physics parameters
        let damping = 0.5;
        const gravity = 500.0;
        let pegRadius = 26.0;

        // Peg array configuration
        const pegRows = 3;
        const pegsPerRow = 7;
        const pegSpacingX = 100;
        const pegSpacingY = 120;
        const pegStartY = 200;

        // Generate peg positions
        function generatePegs() {
            const pegs = [];
            for (let row = 0; row < pegRows; row++) {
                const rowOffset = (row % 2) * (pegSpacingX / 2);
                const rowPegCount = pegsPerRow - (row % 2);
                const rowStartX = (glCanvas.width - (rowPegCount - 1) * pegSpacingX) / 2 + rowOffset - (row % 2) * (pegSpacingX / 2);
                
                for (let col = 0; col < rowPegCount; col++) {
                    pegs.push({
                        x: rowStartX + col * pegSpacingX,
                        y: pegStartY + row * pegSpacingY
                    });
                }
            }
            return pegs;
        }

        const pegs = generatePegs();
        const MAX_PEGS = 24; // Fixed size for shader

        // Bucket configuration
        const bucketColors = [
            [1.0, 0.0, 0.0],    // Red
            [1.0, 0.5, 0.0],    // Orange
            [1.0, 1.0, 0.0],    // Yellow
            [0.0, 1.0, 0.0],    // Green
            [0.0, 0.0, 1.0],    // Blue
            [0.294, 0.0, 0.51], // Indigo
            [0.545, 0.0, 1.0]   // Violet
        ];
        const numBuckets = 7;
        const bucketHeight = 60;
        const bucketY = glCanvas.height - bucketHeight - 10;
        const bucketStartX = 20;
        const bucketWidth = (glCanvas.width - 40) / numBuckets;

        const topRegionHeight = pegStartY - pegRadius - 20;

        // ==================== Shaders ====================
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_coord;
            
            void main() {
                v_coord = a_position * 0.5 + 0.5; // Convert to 0-1 range
                v_coord.x *= 800.0; // Scale to canvas size
                v_coord.y = (1.0 - v_coord.y) * 600.0; // Flip Y and scale
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            varying vec2 v_coord;
            
            uniform float u_damping;
            uniform float u_pegRadius;
            uniform float u_gravity;
            uniform float u_topRegionHeight;
            uniform float u_bucketY;
            uniform float u_bucketStartX;
            uniform float u_bucketWidth;
            uniform vec2 u_pegs[${MAX_PEGS}];
            uniform int u_numPegs;
            uniform vec3 u_bucketColors[7];
            uniform vec3 u_bgColor;
            
            const int MAX_BOUNCES = 50;
            const float EPSILON = 0.0001;
            
            // Solve quadratic: a*t^2 + b*t + c = 0, return smallest positive root or -1
            float solveQuadraticMin(float a, float b, float c) {
                if (abs(a) < 1e-10) {
                    if (abs(b) < 1e-10) return -1.0;
                    float t = -c / b;
                    return t > EPSILON ? t : -1.0;
                }
                
                float disc = b * b - 4.0 * a * c;
                if (disc < 0.0) return -1.0;
                
                float sqrtDisc = sqrt(disc);
                float t1 = (-b - sqrtDisc) / (2.0 * a);
                float t2 = (-b + sqrtDisc) / (2.0 * a);
                
                if (t1 > EPSILON) return t1;
                if (t2 > EPSILON) return t2;
                return -1.0;
            }
            
            // Get position at time t
            vec2 getPosition(vec2 p0, vec2 v0, float t) {
                return p0 + v0 * t + vec2(0.0, 0.5 * u_gravity * t * t);
            }
            
            // Get velocity at time t
            vec2 getVelocity(vec2 v0, float t) {
                return v0 + vec2(0.0, u_gravity * t);
            }
            
            // Find collision time with a single peg using bisection
            float findCollisionTime(vec2 p0, vec2 v0, vec2 center) {
                // Function: |p(t) - center|^2 - r^2 = 0
                // This is a quartic in t, we'll use bisection
                
                float r2 = u_pegRadius * u_pegRadius;
                
                // Sample and bisect
                float tMax = 3.0;
                float step = tMax / 50.0;
                float prevT = 0.0;
                vec2 prevP = p0;
                float prevD = dot(prevP - center, prevP - center) - r2;
                
                for (int i = 1; i <= 50; i++) {
                    float t = float(i) * step;
                    vec2 pos = getPosition(p0, v0, t);
                    float d = dot(pos - center, pos - center) - r2;
                    
                    if (prevD > 0.0 && d < 0.0) {
                        // Entering circle - bisect to find exact time
                        float lo = prevT;
                        float hi = t;
                        
                        for (int j = 0; j < 20; j++) {
                            float mid = (lo + hi) * 0.5;
                            vec2 midPos = getPosition(p0, v0, mid);
                            float midD = dot(midPos - center, midPos - center) - r2;
                            
                            if (midD > 0.0) {
                                lo = mid;
                            } else {
                                hi = mid;
                            }
                        }
                        
                        float collisionT = (lo + hi) * 0.5;
                        
                        // Verify moving toward center
                        vec2 collisionPos = getPosition(p0, v0, collisionT);
                        vec2 collisionVel = getVelocity(v0, collisionT);
                        vec2 toCenter = center - collisionPos;
                        
                        if (dot(collisionVel, toCenter) > 0.0) {
                            return collisionT;
                        }
                    }
                    
                    prevT = t;
                    prevD = d;
                }
                
                return -1.0;
            }
            
            // Compute bounce velocity
            vec2 computeBounceVelocity(vec2 pos, vec2 vel, vec2 center) {
                vec2 n = normalize(pos - center);
                float vDotN = dot(vel, n);
                
                if (vDotN >= 0.0) return vel;
                
                vec2 vn = vDotN * n;
                vec2 vt = vel - vn;
                
                return vt - u_damping * vn;
            }
            
            // Find time to reach bucket level
            float findBucketHitTime(vec2 p0, vec2 v0) {
                return solveQuadraticMin(0.5 * u_gravity, v0.y, p0.y - u_bucketY);
            }
            
            // Get bucket index from x position
            int getBucketIndex(float x) {
                if (x < u_bucketStartX || x >= u_bucketStartX + u_bucketWidth * 7.0) {
                    return -1;
                }
                return int((x - u_bucketStartX) / u_bucketWidth);
            }
            
            // Helper to get peg by index (workaround for no dynamic indexing)
            vec2 getPeg(int idx) {
                for (int i = 0; i < ${MAX_PEGS}; i++) {
                    if (i == idx) return u_pegs[i];
                }
                return vec2(-1000.0);
            }
            
            // Helper to get bucket color by index
            vec3 getBucketColor(int idx) {
                if (idx == 0) return u_bucketColors[0];
                if (idx == 1) return u_bucketColors[1];
                if (idx == 2) return u_bucketColors[2];
                if (idx == 3) return u_bucketColors[3];
                if (idx == 4) return u_bucketColors[4];
                if (idx == 5) return u_bucketColors[5];
                if (idx == 6) return u_bucketColors[6];
                return u_bgColor;
            }
            
            // Main simulation
            int simulateDrop(vec2 startPos) {
                vec2 p0 = startPos;
                vec2 v0 = vec2(0.0, 0.0);
                
                for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
                    // Find earliest collision with any peg
                    float earliestTime = 1000.0;
                    int collidedPeg = -1;
                    
                    for (int i = 0; i < ${MAX_PEGS}; i++) {
                        if (i >= u_numPegs) break;
                        
                        float t = findCollisionTime(p0, v0, u_pegs[i]);
                        if (t > EPSILON && t < earliestTime) {
                            earliestTime = t;
                            collidedPeg = i;
                        }
                    }
                    
                    // Find bucket hit time
                    float bucketTime = findBucketHitTime(p0, v0);
                    
                    // Check what happens first
                    if (bucketTime > EPSILON && bucketTime < earliestTime) {
                        // Reaches bucket
                        vec2 finalPos = getPosition(p0, v0, bucketTime);
                        return getBucketIndex(finalPos.x);
                    }
                    
                    if (collidedPeg >= 0 && earliestTime < 10.0) {
                        // Bounce off peg
                        vec2 collisionPos = getPosition(p0, v0, earliestTime);
                        vec2 collisionVel = getVelocity(v0, earliestTime);
                        vec2 pegPos = getPeg(collidedPeg);
                        v0 = computeBounceVelocity(collisionPos, collisionVel, pegPos);
                        p0 = collisionPos + normalize(collisionPos - pegPos) * 0.1;
                    } else {
                        // Exits without hitting bucket
                        return -1;
                    }
                }
                
                return -1;
            }
            
            void main() {
                // Only compute for top region
                if (v_coord.y > u_topRegionHeight) {
                    gl_FragColor = vec4(u_bgColor, 1.0);
                    return;
                }
                
                int bucketIdx = simulateDrop(v_coord);
                
                vec3 color = getBucketColor(bucketIdx);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Initialize WebGL
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Create fullscreen quad
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]), gl.STATIC_DRAW);

        // Get attribute and uniform locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const dampingLocation = gl.getUniformLocation(program, 'u_damping');
        const pegRadiusLocation = gl.getUniformLocation(program, 'u_pegRadius');
        const gravityLocation = gl.getUniformLocation(program, 'u_gravity');
        const topRegionHeightLocation = gl.getUniformLocation(program, 'u_topRegionHeight');
        const bucketYLocation = gl.getUniformLocation(program, 'u_bucketY');
        const bucketStartXLocation = gl.getUniformLocation(program, 'u_bucketStartX');
        const bucketWidthLocation = gl.getUniformLocation(program, 'u_bucketWidth');
        const numPegsLocation = gl.getUniformLocation(program, 'u_numPegs');
        const bgColorLocation = gl.getUniformLocation(program, 'u_bgColor');

        const pegLocations = [];
        for (let i = 0; i < MAX_PEGS; i++) {
            pegLocations.push(gl.getUniformLocation(program, `u_pegs[${i}]`));
        }

        const bucketColorLocations = [];
        for (let i = 0; i < 7; i++) {
            bucketColorLocations.push(gl.getUniformLocation(program, `u_bucketColors[${i}]`));
        }

        // Render basin with WebGL
        function renderBasinWebGL() {
            const startTime = performance.now();
            
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.useProgram(program);
            
            // Set uniforms
            gl.uniform1f(dampingLocation, damping);
            gl.uniform1f(pegRadiusLocation, pegRadius);
            gl.uniform1f(gravityLocation, gravity);
            gl.uniform1f(topRegionHeightLocation, topRegionHeight);
            gl.uniform1f(bucketYLocation, bucketY);
            gl.uniform1f(bucketStartXLocation, bucketStartX);
            gl.uniform1f(bucketWidthLocation, bucketWidth);
            gl.uniform1i(numPegsLocation, pegs.length);
            gl.uniform3f(bgColorLocation, 15/255, 15/255, 26/255);
            
            // Set peg positions
            for (let i = 0; i < MAX_PEGS; i++) {
                if (i < pegs.length) {
                    gl.uniform2f(pegLocations[i], pegs[i].x, pegs[i].y);
                } else {
                    gl.uniform2f(pegLocations[i], -1000, -1000);
                }
            }
            
            // Set bucket colors
            for (let i = 0; i < 7; i++) {
                gl.uniform3fv(bucketColorLocations[i], bucketColors[i]);
            }
            
            // Draw
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            const elapsed = (performance.now() - startTime).toFixed(1);
            document.getElementById('status').textContent = `Basin computed in ${elapsed}ms (WebGL accelerated)`;
        }

        // ==================== 2D Canvas Overlay ====================
        
        // Bucket rects for overlay
        function getBucketRects() {
            const buckets = [];
            const hexColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#8b00ff'];
            for (let i = 0; i < numBuckets; i++) {
                buckets.push({
                    x: bucketStartX + i * bucketWidth,
                    y: bucketY,
                    width: bucketWidth,
                    height: bucketHeight,
                    color: hexColors[i]
                });
            }
            return buckets;
        }
        const buckets = getBucketRects();

        // Hover state
        let hoverPos = null;

        // JavaScript simulation for trajectory (keep CPU version for hover)
        function solveQuadratic(a, b, c) {
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) return [];
                return [-c/b];
            }
            const disc = b*b - 4*a*c;
            if (disc < 0) return [];
            const sqrtD = Math.sqrt(disc);
            return [(-b - sqrtD)/(2*a), (-b + sqrtD)/(2*a)].sort((a,b) => a-b);
        }

        function getPosition(p0, v0, t) {
            return {
                x: p0.x + v0.x * t,
                y: p0.y + v0.y * t + 0.5 * gravity * t * t
            };
        }

        function getVelocity(v0, t) {
            return { x: v0.x, y: v0.y + gravity * t };
        }

        function findCollisionTime(p0, v0, center, radius) {
            const r2 = radius * radius;
            const tMax = 3;
            const step = tMax / 50;
            let prevT = 0;
            let prevD = (p0.x - center.x)**2 + (p0.y - center.y)**2 - r2;
            
            for (let i = 1; i <= 50; i++) {
                const t = i * step;
                const pos = getPosition(p0, v0, t);
                const d = (pos.x - center.x)**2 + (pos.y - center.y)**2 - r2;
                
                if (prevD > 0 && d < 0) {
                    let lo = prevT, hi = t;
                    for (let j = 0; j < 20; j++) {
                        const mid = (lo + hi) / 2;
                        const midPos = getPosition(p0, v0, mid);
                        const midD = (midPos.x - center.x)**2 + (midPos.y - center.y)**2 - r2;
                        if (midD > 0) lo = mid; else hi = mid;
                    }
                    
                    const collisionT = (lo + hi) / 2;
                    const collisionPos = getPosition(p0, v0, collisionT);
                    const collisionVel = getVelocity(v0, collisionT);
                    const toCenter = { x: center.x - collisionPos.x, y: center.y - collisionPos.y };
                    
                    if (collisionVel.x * toCenter.x + collisionVel.y * toCenter.y > 0) {
                        return collisionT;
                    }
                }
                prevT = t;
                prevD = d;
            }
            return null;
        }

        function findEarliestCollision(p0, v0) {
            let earliestTime = null;
            let collidedPeg = null;
            for (const peg of pegs) {
                const t = findCollisionTime(p0, v0, peg, pegRadius);
                if (t !== null && (earliestTime === null || t < earliestTime)) {
                    earliestTime = t;
                    collidedPeg = peg;
                }
            }
            return { time: earliestTime, peg: collidedPeg };
        }

        function computeBounceVelocity(pos, vel, center) {
            const dx = pos.x - center.x, dy = pos.y - center.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            const nx = dx/len, ny = dy/len;
            const vDotN = vel.x * nx + vel.y * ny;
            if (vDotN >= 0) return vel;
            const vnx = vDotN * nx, vny = vDotN * ny;
            return { x: vel.x - vnx - damping * vnx, y: vel.y - vny - damping * vny };
        }

        function computeTrajectory(startPos) {
            const segments = [];
            let p0 = { ...startPos };
            let v0 = { x: 0, y: 0 };
            
            for (let bounce = 0; bounce < 50; bounce++) {
                const collision = findEarliestCollision(p0, v0);
                const bucketTime = solveQuadratic(0.5 * gravity, v0.y, p0.y - bucketY).find(t => t > 0.0001) || Infinity;
                const exitTime = 10;
                
                const collisionTime = collision.time !== null ? collision.time : Infinity;
                
                if (bucketTime < collisionTime && bucketTime < exitTime) {
                    segments.push({ p0: {...p0}, v0: {...v0}, duration: bucketTime, endsWithBounce: false });
                    break;
                }
                
                if (collisionTime < exitTime) {
                    segments.push({ p0: {...p0}, v0: {...v0}, duration: collisionTime, endsWithBounce: true });
                    const collisionPos = getPosition(p0, v0, collisionTime);
                    const collisionVel = getVelocity(v0, collisionTime);
                    v0 = computeBounceVelocity(collisionPos, collisionVel, collision.peg);
                    p0 = getPosition(p0, { x: 0, y: 0 }, collisionTime + 0.001);
                    const norm = Math.sqrt((collisionPos.x - collision.peg.x)**2 + (collisionPos.y - collision.peg.y)**2);
                    p0 = {
                        x: collisionPos.x + (collisionPos.x - collision.peg.x) / norm * 0.1,
                        y: collisionPos.y + (collisionPos.y - collision.peg.y) / norm * 0.1
                    };
                } else {
                    segments.push({ p0: {...p0}, v0: {...v0}, duration: exitTime, endsWithBounce: false });
                    break;
                }
            }
            return segments;
        }

        // Draw overlay (pegs, buckets, trajectory)
        function drawOverlay() {
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            // Draw pegs
            for (const peg of pegs) {
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 100, 200, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#6666cc';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#6666cc';
                ctx.fill();
            }
            
            // Draw buckets
            for (const bucket of buckets) {
                ctx.fillStyle = bucket.color;
                ctx.fillRect(bucket.x, bucket.y, bucket.width, bucket.height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(bucket.x, bucket.y, bucket.width, bucket.height);
            }
            
            // Draw trajectory on hover
            if (hoverPos && hoverPos.y < topRegionHeight) {
                const segments = computeTrajectory(hoverPos);
                
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                
                for (const segment of segments) {
                    ctx.beginPath();
                    for (let i = 0; i <= 100; i++) {
                        const t = (i / 100) * segment.duration;
                        const pos = getPosition(segment.p0, segment.v0, t);
                        if (i === 0) ctx.moveTo(pos.x, pos.y);
                        else ctx.lineTo(pos.x, pos.y);
                    }
                    ctx.stroke();
                    
                    if (segment.endsWithBounce) {
                        const bouncePos = getPosition(segment.p0, segment.v0, segment.duration);
                        ctx.beginPath();
                        ctx.arc(bouncePos.x, bouncePos.y, 5, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff4444';
                        ctx.fill();
                    }
                }
                
                // Starting point
                ctx.beginPath();
                ctx.arc(hoverPos.x, hoverPos.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Full render
        function render() {
            renderBasinWebGL();
            drawOverlay();
        }

        // ==================== Event Handlers ====================
        const dampingSlider = document.getElementById('damping');
        const pegRadiusSlider = document.getElementById('pegRadius');
        const dampingValue = document.getElementById('dampingValue');
        const pegRadiusValue = document.getElementById('pegRadiusValue');

        dampingSlider.addEventListener('input', () => {
            damping = parseFloat(dampingSlider.value);
            dampingValue.textContent = damping.toFixed(2);
            render();
        });

        pegRadiusSlider.addEventListener('input', () => {
            pegRadius = parseFloat(pegRadiusSlider.value);
            pegRadiusValue.textContent = pegRadius.toFixed(0);
            render();
        });

        function getMousePos(e) {
            const rect = overlayCanvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        overlayCanvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            if (pos.y < topRegionHeight) {
                hoverPos = pos;
                drawOverlay(); // Only redraw overlay, not the whole basin
            } else if (hoverPos !== null) {
                hoverPos = null;
                drawOverlay();
            }
        });

        overlayCanvas.addEventListener('mouseleave', () => {
            if (hoverPos !== null) {
                hoverPos = null;
                drawOverlay();
            }
        });

        // Initial render
        render();
    </script>
</body>
</html>
